<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[js继承几种方式]]></title>
    <url>%2F2018%2F08%2F13%2Fjs%E7%BB%A7%E6%89%BF%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.原型链继承12345678910111213141516function Test(name,age)&#123; this.name = name || '小红' this.age = age || 15 this.fun=function()&#123; console.log(this.name+'今年'+this.age) &#125; &#125; function Test2()&#123; &#125; //Test2的原型等于Test的实例 原型链继承 Test2.prototype = new Test('小明',20) var a = new Test2() a.fun() console.log(a instanceof Test) //true console.log(a instanceof Test2) //true 缺点:* 1.无法实现多继承 * 2.继承属性都是共享的 * 3.创建子类实例时，无法向父类构造函数传参 2.构造函数继承1234567891011121314151617181920function Fun(name,age)&#123; this.name = name this.age = age this.fun=function()&#123; console.log(this.name+'今年'+this.age) &#125; &#125; Fun.prototype.h = function()&#123; console.log('hello') &#125; function Fun2(name,age)&#123; Fun.call(this) //改变this指向 继承了Fun的属性和方法 this.name = name this.age = age &#125; var a = new Fun2('小明',20) var b = new Fun2('小兰',15) a.fun() console.log(a instanceof Fun) //false console.log(a instanceof Fun2) //true 缺点:* 1.实例并不是父类的实例，只是子类的实例 * 2.只能继承父类的实例属性和方法，不能继承原型属性/方法 * 3.无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3.拷贝继承function Fun(name,age){ this.name = name this.age = age this.fun = function(){ console.log(this.name+'今年'+this.age); } } function Fun2(name,age){ var a = new Fun() //遍历实例上的属性和方法拷贝到构造函数原型上 for (p in a){ Fun2.prototype[p] = a[p] } Fun2.prototype.name = name Fun2.prototype.age = age } var b = new Fun2('小花',20) b.fun() console.log(b instanceof Fun) //false console.log(b instanceof Fun2) //true 缺点:* 1.效率较低，内存占用高（因为要拷贝父类的属性） * 2.无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 4.组合继承function Fun2(name,age){ this.name = name this.age = age this.fun = function () { console.log(this.name+'今年'+this.age) } } Fun.prototype.h = function(){ console.log('hello world'); } function Fun(name,age){ Fun2.call(this) this.name = name this.age = age } //Fun构造函数复制给Fun2的原型上 Fun2.prototype = new Fun() var a = new Fun2('小兰',30) a.fun() a.h() console.log(a instanceof Fun) //true console.log(a instanceof Fun2) //true 缺点:* 1.调用了两次父类构造函数，生成了两份实例 5.寄生继承function Fun2(name,age){ this.name = name this.age = age this.fun = function () { console.log(this.name+'今年'+this.age) } } Fun.prototype.h = function(){ console.log('hello world'); } function Fun(name,age){ Fun2.call(this) this.name = name this.age = age } (function(){ //再次创建没有实例的构造函数 var Fun3 = function(){} //将Fun原型复制给Fun3 Fun实例上边会有Fun原型上的属性和方法 Fun3.prototype = Fun.prototype //Fun3的实例赋值给Fun2的原型 所以Fun2的实例会有Fun3原型上的属性和方法 Fun2.prototype = new Fun3() })() var a = new Fun2('小兰',30) a.fun() a.h() console.log(a instanceof Fun) //true console.log(a instanceof Fun2) //true]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组常用方法]]></title>
    <url>%2F2018%2F08%2F13%2F%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.push() 向数组末尾添加元素12var arr = [1,2,3,4]arr.push(5) //输出[1,2,3,4,5] 返回数组长度 2.unshift 向数组前面添加元素12var arr = [1,2,3]arr.unshift(0) //输出[0,1,2,3] 返回数组长度 3.pop() 删除数组最后一个元素 该方法会改变原数组12var arr = [1,2,3]arr.pop() //输出[1,2] 返回删除的元素 4.shift() 删除数组第一个元素 该方法会改变原数组12var arr = [1,2,3]arr.shift() //输出[2,3] 返回删除元素 5.slice() 截取数组123456//参数//1.截取start位置 2.截取end位置但不包括//如果不传end则截取start位置之后的所有var arr = [1,2,3,4,5]var a = arr.slice(0,3) //输出[1,2,3] 会返回新数组var b = arr.slice(3) //输出[4,5] 6.splice() 方法可以从数组添加、删除元素123456//参数 1.规定添加/删除项目的位置 //2.要删除的项目数量,如果设置为0，则不会删除项目//3.要添加的元素(可选)var arr = [1,2,3,4]arr.splice(1,1) //返回[2] 从数组下标为1的位置删除一个元素arr.splice(1,0,1) //返回[1,1,2,3,4] 从数组下标位置添加元素 7.concat() 合并两个或多个数组 不会改变原数组123var arr1 = [1,2,3]var arr2 = [4,5,6]var a = arr1.concat(arr2) //输出[1,2,3,4,5,6] 返回新的数组 8.indexOf() 查找元素在数组的位置123//参数 1.产找的字符串值 2.开始查找的位置 如省略从数组首个元素开始var arr = [1,2,3,4]arr.indexOf(4) //输出3 存在就返回下标 不存在返回-1 9.join() 数组转为字符串123//参数 1.指定要使用的分隔符 省略则使用逗号var arr = [1,2,3]arr.join() //输出1,2,3 10.reverse() 颠倒数组 该方法会改变原数组12var arr = [1,2,3]arr.reverse() //输出[3,2,1] 11.forEach() 遍历数组 一般用于操作原数组 没有返回值12345//参数 1.当前元素 2.下标var arr = [1,2,3]arr.forEach(function(item,index)&#123; console.log(item,index) //输出1,2,3 &#125;) 12.map() 遍历数组 与forEach类似 会创建新数组并返回12345//参数 1.当前元素 2.下标var arr = [1,2,3]arr.map(function(item,inedx)&#123; console.log(item,index) //输出1,2,3&#125;) 13.includes() 判断数组是否包含某个值123var arr = [1,2,3]arr.includes(1) //truearr.includes(5) //false 14.reduce() 累加元素1234var arr = [1,2,3]arr.reduce(function(x,y)&#123; return x+y //输出6 将数组元素累加&#125;) 15.filter() 数组过滤1234var arr = [1,2,3,4,5]arr.filter(function(item)&#123; return item &gt; 3 //输出[4,5] 返回新数组&#125;)]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call apply bind区别]]></title>
    <url>%2F2018%2F08%2F13%2Fcall-apply-bind%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[例子123456789101112131415var name = '小明',age=20var obj = &#123; name : '小红', objage:this.age, myFun:function()&#123; console.log(this.name+'年龄'+this.age) &#125; &#125; var obj2 = &#123; age : 30, name : '小兰' &#125;obj.myFun.call(obj2) //将obj的this改变为obj2 所以输出小兰年龄30obj.myFun.apply(obj2) //同样是将obj的this改变为obj2 所以输出小兰年龄30obj.myFun.bind(obj2)()//这个稍微有点不用，后边多了一个括号，因为bind返回的是一个函数，需要再次调用，同样是将this改为obj2 在看传参方式12345678910111213141516var name = '小明',age=20 var obj = &#123; name : '小红', objage:this.age, myFun:function(address,play)&#123; console.log(this.name+'年龄'+this.age+'来自'+address+'去过'+play) &#125; &#125; var obj2 = &#123; age : 30, name : '小兰' &#125;//传参obj.myFun.call(obj2,'上海','成都') //call传参方式就是以普通方式传入obj.myFun.apply(obj2,['北京','美国']) //apply传参方式是以数组方式传入obj.myFun.bind(obj2,'深圳','韩国')() //bind传参方式就是以普通方式传入 区别 1.call、apply、bind第一个参数都是改变this指向 2.call、apply调用一次就可以，bind是需要再次调用 3.call、bind传参方式都是普通传入用逗号隔开就好，apply是传入数组]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js数组去重的几种方法]]></title>
    <url>%2F2018%2F06%2F25%2Fjs%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组去重的几种方式方式1：利用indexOf 遍历数组去重的数组，根据indexOf去判断新数组有没有这个值,有的话就返回索引下标，没有的话就返回-1，如果没有就push到这个新数组中，最后将这个新数组返回实现去重123456789101112var arr = [1,2,3,1,2,3,4,5,6,6,5,4]function delre(arr)&#123; var ret = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (ret.indexOf(arr[i]) === -1)&#123; ret.push(arr[i]) &#125; &#125; return ret&#125;console.log(delre(arr))输出:[1,2,3,4,5,6] 方式2：遍历数组，利用object对象保存数组值，判断数组值是否已经保存在object中，未保存则push到新数组并用object[arrayItem]=1的方式记录保存12345678910111213function delre(arr)&#123; var obj = &#123;&#125; var ret = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]])&#123; obj[arr[i]] = 1 ret.push(arr[i]) &#125; &#125; return ret&#125;console.log(delre(arr))输出:[1,2,3,4,5,6] 方式3：数组下标判断法, 遍历数组，利用indexOf判断元素的值是否与当前索引相等，如相等则加入1234567891011function delre(arr)&#123; var ret = [] arr.forEach((e,i)=&gt;&#123; if (arr.indexOf(e)===i)&#123; ret.push(e) &#125; &#125;) return ret&#125;console.log(delre(arr))输出:[1,2,3,4,5,6] 方式4：Es6的set方法123456function delre(arr)&#123; var ret = new Set(arr) return Array.from(ret)&#125;console.log(delre(arr))输出:[1,2,3,4,5,6] 方式5：嵌套循环依次比较12345678910111213function delre(arr)&#123; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] === arr[j])&#123; arr.splice(j,1) j-- &#125; &#125; &#125; return arr&#125;console.log(delre(arr))输出:[1,2,3,4,5,6]]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的循环机制]]></title>
    <url>%2F2018%2F06%2F20%2Fjs%E7%9A%84%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言大家都知道js是单线程的脚本语言，在同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞 为什么js是单线程？js作为主要是运行在浏览器的脚本语言，js主要用途之一是操作DOM 如果js同时有两个线程，同时对同一个dom进行操作，这时浏览器应该听哪一个的线程的，如何判断优先级？为了避免这个问题，js必须是一门单线程语言 执行栈与任务队列因为js是单线程语言，当遇到异步任务(如ajax操作时)，不可能一直等待异步任务完成，在继续往下执行，在这期间浏览器是空闲状态，显而易见这会导致巨大的资源浪费。 执行栈当执行某个函数、用户点击一次鼠标，ajax完成，一个图片加载完成等事件发生时，只要指定过回调函数，这些事件发生就会进入执行栈队列中，等待主线程读取，遵循先进先出原则。 主线程要明确的一点是，主线程跟执行栈是不同概念，主线程规定现在执行执行栈中的哪个时间。 主线程循环：主线程会不停的从执行栈中读取时间，会执行完所有栈中的同步代码。当遇到一个异步事件后，并不会一直等待异步事件返回结果，而是会将这个事件挂在与执行栈不同的队列中，我们称之为任务队列(Task Queue)。当主线程将执行栈中所有的代码执行完之后，主线程将会去查看任务队列是否有任务，如果有，那么主线程会依次执行那些任务队列中的回调函数。 js异步执行的运行机制 1.所有任务都在主线程上执行，形成一个执行栈 2.主线程之外，还存在一个’任务队列’(Task Queue)，只要异步任务有了运行结果，就在’任务队列’中放置一个事件 3.一旦’执行栈’中的所有同步任务执行完毕，系统就会读取’任务队列’，那些对应的任务结束等待状态，进入执行栈并开始执行 4.主线程不断重复上面的第三步 事件循环需要记住以下几点: 事件队列严格按照时间先后顺序将任务压入执行栈执行 当执行栈为空时，浏览器会一直不停的检查事件队列，如果不为空，则取出第一个任务 在每一个任务结束之后，浏览器会对页面进行渲染]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除浮动的几种方法]]></title>
    <url>%2F2018%2F05%2F25%2F%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[清除浮动的几种方法为什么要清除浮动呢请看如下代码: html1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; css12345678910111213141516.box&#123; width: 300px; border: 1px solid #000; &#125; .left&#123; width: 100px; height: 100px; background-color: pink; float: left; &#125; .right&#123; width: 100px; height: 100px; background-color: red; float: right; &#125; 我要让left和right两个div在box盒子里左右浮动，当然这样写没有什么毛病，但是两个盒子因为浮动的原因脱离了文档流，导致父元素box高度塌陷，不能被内容撑开，如下图：这样我们已经看到了父元素的高度已经没有了，这就是我们清除浮动的原因了 接下来我们看一下清除浮动的几种方法方法一：在盒子里边添加一个元素添加设置.clear{clear:both;}样式 html12345&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="clear"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819.box&#123; width: 300px; border: 1px solid #000; &#125;.left&#123; width: 100px; height: 100px; background-color: pink; float: left; &#125; .right&#123; width: 100px; height: 100px; background-color: red; float: right; &#125; .clear&#123; clear: both; &#125; 效果图如下：达到了我们想要的效果 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单，代码少，浏览器支持好，不容易出现怪问题 缺点：如果页面浮动布局多，就要增加很多空div，让人感觉很不爽 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 方法二：给box父元素添加 overflow:hidden或者auto样式1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718.box&#123; width: 300px; border: 1px solid #000; overflow:hidden; zoom:1; //兼容IE &#125;.left&#123; width: 100px; height: 100px; background-color: pink; float: left; &#125; .right&#123; width: 100px; height: 100px; background-color: red; float: right; &#125; 当然效果图还是和上边一样的，父元素正常被撑开了 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单，代码少，浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用 方法三：利用伪元素 box:after 来设置样式，清除浮动1234&lt;div class="box"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223.box&#123; width: 300px; border: 1px solid #000; &#125;.box:after&#123; content: ""; height: 0; clear: both; display: block; visibility: hidden; &#125;.left&#123; width: 100px; height: 100px; background-color: pink; float: left; &#125; .right&#123; width: 100px; height: 100px; background-color: red; float: right; &#125; 这样一样被撑开了 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多，要两句代码结合使用，才能让主流浏览器都支持 建议：推荐使用，建议定义公共类，以减少CSS代码 其实还有很多清除浮动的方法不过都没有什么优点比如： 让父元素盒子一起浮动，这样就导致他们成了一个整体，没有优点还会产生新的浮动问题 给父元素添加高度，但是这样高度就不能自适应了，当然也不太合适 将父元素设置为display:table，缺点未知 在这里还是推荐方法三]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序request接口封装实例]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%B0%8F%E7%A8%8B%E5%BA%8Frequest%E6%8E%A5%E5%8F%A3%E5%B0%81%E8%A3%85%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[使用Promise对小程序wx.request接口进行封装新建一个request.js文件，代码如下:12345678910111213141516171819202122232425 //url 接口地址 //method 请求方式 //data 要传给服务器端的数据 没有的话传个&#123;&#125;就可以 //还需要别的在添加就ok function request(url,method,data)&#123; return new Promise((resolve,reject)=&gt;&#123; wx.request(&#123; url, method, data:&#123;data&#125;, header: &#123; 'content-type': 'application/json' &#125;, success:function(res)&#123; resolve(res) &#125;, fail:function(error)&#123; reject(error) &#125; &#125;) &#125;)&#125;module.exports = &#123; request&#125; 在文件中使用12345678910//引入封装好的request文件var request = require('文件路径')//这里已post为例request.request('url','POST',data) .then((res)=&gt;&#123; // 请求成功函数 &#125;) .error((error)=&gt;&#123; //请求失败函数 &#125;)]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序实现下拉刷新和上拉加载]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%92%8C%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[下拉刷新下拉刷新两个步骤 在要添加下拉刷新页面的json文件添加如下代码： 1"enablePullDownRefresh":true //来开始下拉刷新 添加背景颜色，不添加的话默认是白色，会与背景颜色相同，看不见icon 1"backgroundColor":"dark" 在要实现下拉刷新的页面添加下拉刷新函数123onPullDownRefresh() &#123; wx.showNavigationBarLoading() //在标题栏中显示加载loading&#125; 下拉刷新完成之后调用如下函数来停止刷新1234onPullDownRefresh() &#123; wx.showNavigationBarLoading() //在标题栏中显示加载loading wx.stopPullDownRefresh() //停止刷新&#125; 上拉加载上垃加载主要是利用了js中的onReachBottom方法，它表示”页面上拉触底事件的处理函数”，我们就在这时请求服务器获取到对应数据123onReachBottom:function()&#123; //请求数据&#125;]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo多台电脑更新博客]]></title>
    <url>%2F2018%2F05%2F22%2Fhexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[创建分支 hexo生成的静态博客文件都是传到github上的，且默认放在master分支上，而配置文件都是放在本地的 hexo(配置文件)都是可以放到hexo分支上(创建一个新的分支)，切换电脑时，直接git clone hexo分支 在xxx.github.io仓库下创建一个新的hexo分支切换到hexo分支，并在-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设置为hexo，save保存 克隆hexo分支到本地 将新建的hexo分支克隆到本地，在终端中cd到xxx.github.io文件夹 使用git branch查看分支，应该默认是hexo 部署文件 将本地的hexo配置文件(全部文件)全部拷贝到xxx.github.io文件根目录下 安装需要用到的插件(可选) 123456789101112131415npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --savenpm install hexo-generator-search --savenpm install hexo-generator-searchdb --save 将文件全部提交到hexo分支 注意事项 1.主题文件夹下边可能会有.git、.github隐藏文件夹，将文件删除在提交，不然可能会提交不上去 master分支和hexo分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；hexo分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内也不会有任何冲突 在其他电脑更新博客 在新电脑克隆xxx.github.io仓库的hexo分支到本地 cd到xxx.github.io文件夹下，执行npm install 现在就可以在不同电脑下更新博客了]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github搭建hexo个人博客]]></title>
    <url>%2F2018%2F05%2F22%2F%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备工作 1.准备一个github账号，没有的话去github注册 2.电脑安装node、git、npm 安装hexo 当node、git都安装完成之后，在终端运行如下命令：1npm install -g hexo 开始搭建 1.在电脑中新建一个空文件夹，名字随意，如MyBlog 2.cd到当前文件夹 3.在终端运行如下命令，生成模板1hexo init 安装完模板应该会有一个package.json文件，执行如下命令安装依赖：1npm install 然后运行如下命令开始hexo服务器:1hexo s 输入http://localhost:4000/，应该就可以看到以下页面 关联github新建一个github仓库 在github上创建名字为XXX.github.io的项目，xxx必须是自己github账号的用户名 修改_fonfig.yml配置文件 1.打开本地MyBlog根目录下边的_fonfig.yml配置文件 2.将其中的type设置为git，repository是你github.io仓库的地址 3.每次个属性冒号后边都要加一个空格，不然会报错1234deploy: type: git repository: https://github.com/CoderTitan/CoderTitan.github.io.git branch: master 将配置文件部署到github上 打开终端，cd到MyBlog文件夹下，执行如下命令 在MyBlog根目录下执行如下命令生成静态文件：1hexo generate 或者：hexo g 此时若出现如下报错：12ERROR Local hexo not found in ~/blogERROR Try runing: 'npm install hexo --save' 则执行命令：1npm install hexo --save 再执行配置命令：1hexo deploy 或者：hexo d 报错一: 若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：1npm install hexo-deployer-git --save 报错二: 若执行命令hexo d报以下错误:123ERROR Plugin load failed: hexo-server//或者类似的错误ERROR Plugin load failed: hexo-renderer-sass 则执行响应的命令:123sudo npm install hexo-server//或者sudo npm install hexo-renderer-sass 最后执行：1hexo d hexo d执行完成后，在浏览器打开http://xxx.github.io就能看到搭建好的博客了 安装主题 我们可以去官方网站下载主题 示例next cd到MyBlog根目录下执行1git clone https://github.com/theme-next/hexo-theme-next themes/next 下载的主题默认是在theme文件夹下，然后重新执行hexo g来生成 每次部署文章的步骤12345hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件 hexo d //重新部署到服务器 域名绑定 现在使用的域名是Github提供的二级域名XXX.github.io，也可以绑定为自己的个性域名 可以到阿里万网购买，可以直接在网站做域名解析 域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析, 如下图进入解析页面后点击添加解析, 向你的 DNS 配置中添加 3 条记录, 如下图注意CNAME记录添加的是username.github.io.(不要忘记后面的.), 可能最后一个点不显示(我的就不显示) 设置github配置信息 打开你的xxx.github.io项目地址，找到设置页面 滚动到下方找到github pages模块，在custom domain，输入你购买的域名，点击save保存 创建CNAME文件 在/MyBlog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名写入 CNAME一定要大写 完成上述步骤后, 终端cd到MyBlog目录下执行如下命令重新部署： 最后, 等十分钟左右，刷新浏览器，用你自己域名访问下试试 12345hexo cleanhexo ghexo d]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
